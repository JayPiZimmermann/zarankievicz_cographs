<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extremal Cograph Viewer - D3.js</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: #f8f9fa;
            overflow: hidden;
        }

        #app {
            display: grid;
            grid-template-columns: 280px 1fr 320px;
            grid-template-rows: 60px 1fr;
            height: 100vh;
            gap: 0;
        }

        #header {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 25px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        #header h1 {
            font-size: 24px;
            font-weight: 600;
        }

        #header .stats {
            font-size: 14px;
            opacity: 0.9;
        }

        #header .folder-selector {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #header .folder-selector select {
            padding: 6px 12px;
            border-radius: 5px;
            border: none;
            font-size: 13px;
            background: rgba(255,255,255,0.9);
            cursor: pointer;
            min-width: 180px;
        }

        #header .folder-selector select:disabled {
            opacity: 0.7;
            cursor: wait;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-overlay.hidden {
            display: none;
        }

        .loading-box {
            background: white;
            padding: 30px 50px;
            border-radius: 10px;
            text-align: center;
        }

        .loading-box .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #e9ecef;
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .no-folder-message {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #6c757d;
            text-align: center;
            padding: 40px;
        }

        .no-folder-message h3 {
            font-size: 20px;
            margin-bottom: 10px;
            color: #495057;
        }

        .no-folder-message p {
            font-size: 14px;
            max-width: 300px;
        }

        #sidebar {
            background: white;
            border-right: 1px solid #dee2e6;
            overflow-y: auto;
            padding: 20px;
        }

        #main {
            background: white;
            position: relative;
        }

        #info-panel {
            background: white;
            border-left: 1px solid #dee2e6;
            overflow-y: auto;
            padding: 20px;
        }

        h2 {
            font-size: 16px;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }

        .filter-group {
            margin-bottom: 20px;
        }

        .filter-group label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            color: #555;
            margin-bottom: 6px;
        }

        .filter-group select,
        .filter-group input {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            font-size: 13px;
            background: white;
        }

        .filter-group input[type="checkbox"] {
            width: auto;
            margin-right: 8px;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: 8px 0;
        }

        .button-group {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        button {
            padding: 8px 14px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: background 0.2s;
        }

        button:hover {
            background: #5568d3;
        }

        button.secondary {
            background: #6c757d;
        }

        button.secondary:hover {
            background: #5a6268;
        }

        #graph-list {
            margin-top: 15px;
        }

        .graph-item {
            padding: 12px;
            margin-bottom: 8px;
            background: #f8f9fa;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .graph-item:hover {
            background: #e9ecef;
            transform: translateX(2px);
        }

        .graph-item.active {
            background: #e7f1ff;
            border-color: #667eea;
        }

        .graph-item.exceptional {
            background: #fff3cd;
            border-left: 3px solid #ffc107;
        }

        .graph-item.exceptional.active {
            background: #fff3cd;
            border-color: #ffc107;
        }

        .graph-label {
            font-weight: 600;
            color: #495057;
            font-size: 13px;
            margin-bottom: 4px;
        }

        .graph-meta {
            font-size: 11px;
            color: #6c757d;
        }

        .exceptional-badge {
            display: inline-block;
            background: #ffc107;
            color: #000;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
            margin-left: 5px;
        }

        svg {
            width: 100%;
            height: 100%;
        }

        .node {
            stroke: #fff;
            stroke-width: 2px;
            cursor: move;
        }

        .node:hover {
            stroke: #ffc107;
            stroke-width: 3px;
        }

        .link {
            stroke: #999;
            stroke-opacity: 0.3;
            stroke-width: 1.5px;
        }

        .link:hover {
            stroke-opacity: 0.7;
        }

        .node-label {
            font-size: 10px;
            font-weight: 600;
            fill: #333;
            pointer-events: none;
            user-select: none;
        }

        .slider-group {
            margin: 15px 0;
        }

        .slider-group label {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #555;
            margin-bottom: 5px;
        }

        input[type="range"] {
            width: 100%;
        }

        .info-section {
            margin-bottom: 20px;
        }

        .info-section h3 {
            font-size: 14px;
            color: #667eea;
            margin-bottom: 8px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid #e9ecef;
            font-size: 13px;
        }

        .info-label {
            font-weight: 500;
            color: #6c757d;
        }

        .info-value {
            font-weight: 600;
            color: #333;
        }

        pre {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 5px;
            font-size: 11px;
            overflow-x: auto;
            border: 1px solid #dee2e6;
            max-height: 200px;
        }

        .controls-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 10;
        }

        .control-item {
            margin-bottom: 10px;
        }

        .control-item:last-child {
            margin-bottom: 0;
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="header">
            <h1>Extremal Cograph Viewer</h1>
            <div class="folder-selector">
                <label style="font-size: 13px;">Exports folder:</label>
                <select id="folder-select">
                    <option value="">-- Select folder --</option>
                </select>
                <label style="font-size: 12px; display: flex; align-items: center; gap: 5px; cursor: pointer;">
                    <input type="checkbox" id="force-recalculate" style="cursor: pointer;">
                    Recalculate
                </label>
            </div>
            <div class="stats">
                <span id="total-graphs">0</span> graphs loaded
                | <span id="current-graph-label">Select a graph</span>
            </div>
        </div>

        <div id="loading-overlay" class="loading-overlay hidden">
            <div class="loading-box">
                <div class="spinner"></div>
                <div>Loading graphs...</div>
            </div>
        </div>

        <div id="sidebar">
            <h2>Filters</h2>

            <div class="filter-group">
                <label for="filter-st">Filter by K_{s,t}:</label>
                <select id="filter-st">
                    <option value="">All</option>
                </select>
            </div>

            <div class="filter-group">
                <label for="filter-n">Filter by n:</label>
                <select id="filter-n">
                    <option value="">All</option>
                </select>
            </div>

            <div class="filter-group">
                <label class="checkbox-label">
                    <input type="checkbox" id="filter-exceptional">
                    Show only exceptional cases
                </label>
            </div>

            <div class="button-group">
                <button onclick="resetFilters()">Reset Filters</button>
            </div>

            <h2 style="margin-top: 20px;">Graphs</h2>
            <div id="graph-list"></div>
        </div>

        <div id="main">
            <div class="controls-panel">
                <div class="control-item">
                    <button onclick="togglePhysics()"id="physics-toggle">Freeze Physics</button>
                </div>
                <div class="control-item">
                    <button onclick="toggleLabels()" class="secondary">Toggle Labels</button>
                </div>
                <div class="control-item">
                    <button onclick="resetPositions()" class="secondary">Reset Layout</button>
                </div>
                <div class="slider-group">
                    <label>
                        <span>Link Strength</span>
                        <span id="link-strength-val">30</span>
                    </label>
                    <input type="range" id="link-strength" min="-100" max="100" step="1" value="30">
                </div>
                <div class="slider-group">
                    <label>
                        <span>Charge Force</span>
                        <span id="charge-strength-val">-30</span>
                    </label>
                    <input type="range" id="charge-strength" min="-100" max="100" step="1" value="-30">
                </div>
                <div class="slider-group">
                    <label>
                        <span>Sum Component Force</span>
                        <span id="sum-force-val">0</span>
                    </label>
                    <input type="range" id="sum-force" min="-100" max="100" step="1" value="0">
                </div>
                <div class="slider-group">
                    <label>
                        <span>Product Component Force</span>
                        <span id="product-force-val">0</span>
                    </label>
                    <input type="range" id="product-force" min="-100" max="100" step="1" value="0">
                </div>
            </div>
            <svg id="graph-svg"></svg>
        </div>

        <div id="info-panel">
            <h2>Graph Information</h2>
            <div id="info-content">
                <p style="color: #6c757d; font-size: 13px;">Select a graph from the list to view details</p>
            </div>
        </div>
    </div>

    <script>
        let allGraphs = [];
        let filteredGraphs = [];
        let currentGraph = null;
        let simulation = null;
        let physicsEnabled = true;
        let showLabels = false;
        let currentFolder = null;

        // SVG setup
        const svg = d3.select("#graph-svg");
        const width = document.getElementById("main").clientWidth;
        const height = document.getElementById("main").clientHeight;

        svg.attr("viewBox", [0, 0, width, height]);

        const g = svg.append("g");
        const linkGroup = g.append("g").attr("class", "links");
        const nodeGroup = g.append("g").attr("class", "nodes");
        const labelGroup = g.append("g").attr("class", "labels");

        // Zoom
        const zoom = d3.zoom()
            .scaleExtent([0.1, 10])
            .on("zoom", (event) => {
                g.attr("transform", event.transform);
            });

        svg.call(zoom);

        // Show/hide loading overlay
        function showLoading(show) {
            document.getElementById("loading-overlay").classList.toggle("hidden", !show);
            document.getElementById("folder-select").disabled = show;
        }

        // Show "no folder selected" message
        function showNoFolderMessage() {
            const list = d3.select("#graph-list");
            list.html(`
                <div class="no-folder-message">
                    <h3>No folder selected</h3>
                    <p>Select an exports folder from the dropdown above to view graphs</p>
                </div>
            `);
            d3.select("#total-graphs").text("0");
            d3.select("#current-graph-label").text("Select a folder first");

            // Clear the graph display
            linkGroup.selectAll("*").remove();
            nodeGroup.selectAll("*").remove();
            labelGroup.selectAll("*").remove();

            // Clear info panel
            d3.select("#info-content").html(`
                <p style="color: #6c757d; font-size: 13px;">Select a folder and graph to view details</p>
            `);
        }

        // Load available folders
        async function loadFolders() {
            try {
                const response = await fetch("/api/folders");
                const folders = await response.json();

                const select = document.getElementById("folder-select");
                // Clear existing options except the first
                while (select.options.length > 1) {
                    select.remove(1);
                }

                folders.forEach(folder => {
                    const option = document.createElement("option");
                    option.value = folder.path;
                    const cacheIndicator = folder.has_cache ? " [cached]" : "";
                    option.textContent = `${folder.name} (${folder.file_count} files)${cacheIndicator}`;
                    select.appendChild(option);
                });
            } catch (error) {
                console.error("Failed to load folders:", error);
            }
        }

        // Handle folder selection
        async function selectFolder(folderPath, force = false) {
            if (!folderPath) {
                showNoFolderMessage();
                return;
            }

            showLoading(true);
            currentFolder = folderPath;

            try {
                const response = await fetch("/api/select-folder", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ folder: folderPath, force: force })
                });

                const result = await response.json();
                if (!response.ok) {
                    alert("Error: " + (result.error || "Failed to load folder"));
                    showLoading(false);
                    return;
                }

                // Load data directly from response
                allGraphs = result.data || [];
                currentGraph = null;

                if (allGraphs.length === 0) {
                    showNoFolderMessage();
                    return;
                }

                // Update status to show if cache was used
                const statusText = result.used_cache ? "(cached)" : "(generated)";
                console.log(`Loaded ${allGraphs.length} graphs ${statusText}`);

                // Refresh folder list to update cache indicators
                const currentValue = document.getElementById("folder-select").value;
                await loadFolders();
                document.getElementById("folder-select").value = currentValue;

                initializeFilters();
                applyFilters();

            } catch (error) {
                console.error("Failed to select folder:", error);
                alert("Failed to load folder: " + error.message);
            } finally {
                showLoading(false);
            }
        }

        // Initialize on page load
        document.addEventListener("DOMContentLoaded", async () => {
            await loadFolders();

            // Set up folder selector
            document.getElementById("folder-select").addEventListener("change", (e) => {
                const forceRecalc = document.getElementById("force-recalculate").checked;
                selectFolder(e.target.value, forceRecalc);
            });

            // Show no folder message initially
            showNoFolderMessage();
        });

        function initializeFilters() {
            // Clear existing options first
            const stSelect = d3.select("#filter-st");
            stSelect.selectAll("option").remove();
            stSelect.append("option").attr("value", "").text("All");

            const nSelect = d3.select("#filter-n");
            nSelect.selectAll("option").remove();
            nSelect.append("option").attr("value", "").text("All");

            // Populate s,t filter
            const stSet = new Set(allGraphs.map(g => `${g.s},${g.t}`));
            Array.from(stSet).sort().forEach(st => {
                const [s, t] = st.split(',');
                stSelect.append("option")
                    .attr("value", st)
                    .text(`K_{${s},${t}}`);
            });

            // Populate n filter
            const nSet = new Set(allGraphs.map(g => g.n));
            Array.from(nSet).sort((a, b) => a - b).forEach(n => {
                nSelect.append("option")
                    .attr("value", n)
                    .text(`n = ${n}`);
            });

            // Reset exceptional checkbox
            d3.select("#filter-exceptional").property("checked", false);

            // Event listeners
            d3.select("#filter-st").on("change", applyFilters);
            d3.select("#filter-n").on("change", applyFilters);
            d3.select("#filter-exceptional").on("change", applyFilters);

            // Slider listeners
            d3.select("#link-strength").on("input", updateLinkStrength);
            d3.select("#charge-strength").on("input", updateChargeStrength);
            d3.select("#sum-force").on("input", updateSumForce);
            d3.select("#product-force").on("input", updateProductForce);

            d3.select("#total-graphs").text(allGraphs.length);
        }

        function applyFilters() {
            const stFilter = d3.select("#filter-st").property("value");
            const nFilter = d3.select("#filter-n").property("value");
            const exceptionalOnly = d3.select("#filter-exceptional").property("checked");

            filteredGraphs = allGraphs.filter(g => {
                if (stFilter && `${g.s},${g.t}` !== stFilter) return false;
                if (nFilter && g.n !== parseInt(nFilter)) return false;
                if (exceptionalOnly && !g.is_exceptional) return false;
                return true;
            });

            renderGraphList();
        }

        function resetFilters() {
            d3.select("#filter-st").property("value", "");
            d3.select("#filter-n").property("value", "");
            d3.select("#filter-exceptional").property("checked", false);
            applyFilters();
        }

        function renderGraphList() {
            const list = d3.select("#graph-list");
            list.selectAll("*").remove();

            filteredGraphs.forEach((graph, i) => {
                const item = list.append("div")
                    .attr("class", `graph-item ${graph.is_exceptional ? 'exceptional' : ''}`)
                    .on("click", () => loadGraph(graph));

                item.append("div")
                    .attr("class", "graph-label")
                    .html(`${graph.label}${graph.is_exceptional ? '<span class="exceptional-badge">EXCEPTION</span>' : ''}`);

                const metaText = [
                    `V: ${graph.n}`,
                    `E: ${graph.edges_count}`,
                    `D: ${graph.depth}`,
                    graph.last_op ? `Op: ${graph.last_op}` : null,
                    graph.component_sizes && graph.component_sizes.length > 0 ? `Comp: [${graph.component_sizes.join(',')}]` : null,
                    `#${graph.struct_index + 1}/${graph.total_structures}`
                ].filter(x => x !== null).join(' | ');

                item.append("div")
                    .attr("class", "graph-meta")
                    .text(metaText);
            });

            // Auto-load first graph
            if (filteredGraphs.length > 0 && !currentGraph) {
                loadGraph(filteredGraphs[0]);
            }
        }

        function loadGraph(graph) {
            currentGraph = graph;

            // Update active state
            d3.selectAll(".graph-item").classed("active", false);
            d3.selectAll(".graph-item").filter(function() {
                return d3.select(this).text().includes(graph.label);
            }).classed("active", true);

            // Update header
            d3.select("#current-graph-label").text(graph.label);

            // Prepare data
            const nodes = graph.nodes.map(n => ({...n}));
            const links = graph.links.map(l => ({...l}));

            // Clear existing
            linkGroup.selectAll("*").remove();
            nodeGroup.selectAll("*").remove();
            labelGroup.selectAll("*").remove();

            // Create force simulation with structure-aware parameters
            if (simulation) {
                simulation.stop();
            }

            // Use pre-computed positions as initial positions
            nodes.forEach(n => {
                n.x = n.x || width / 2;
                n.y = n.y || height / 2;
            });

            // Build adjacency for structure detection
            const adjacency = new Map();
            nodes.forEach(n => adjacency.set(n.id, new Set()));
            links.forEach(l => {
                const src = typeof l.source === 'object' ? l.source.id : l.source;
                const tgt = typeof l.target === 'object' ? l.target.id : l.target;
                adjacency.get(src).add(tgt);
                adjacency.get(tgt).add(src);
            });

            // Detect hub nodes (high degree relative to graph size)
            const avgDegree = links.length * 2 / nodes.length;
            nodes.forEach(n => {
                const degree = adjacency.get(n.id).size;
                n.isHub = n.is_hub || degree > avgDegree * 1.5;
            });

            // Structure-aware link distance
            function linkDistance(link) {
                const src = link.source;
                const tgt = link.target;

                // If connecting to hub, use longer distance
                if (src.isHub || tgt.isHub) {
                    return 80;
                }

                // Same branch: tight clustering
                if (src.branch !== undefined && src.branch === tgt.branch) {
                    return 30;
                }

                // Same multipartite part: tight
                if (src.multipartite_part !== undefined && src.multipartite_part === tgt.multipartite_part) {
                    return 30;
                }

                // Different branches/parts: longer
                return 60;
            }

            // Structure-aware link strength
            function linkStrength(link) {
                const src = link.source;
                const tgt = link.target;

                // Hub connections: weaker to allow radial spread
                if (src.isHub || tgt.isHub) {
                    return 0.3;
                }

                // Same structural group: strong
                if (src.branch !== undefined && src.branch === tgt.branch) {
                    return 1.0;
                }

                // Cross-branch: weaker
                return 0.5;
            }

            // Structure-aware charge (repulsion)
            function chargeStrength(node) {
                // Hub nodes need more space
                if (node.isHub) {
                    return -150;
                }
                // Regular nodes
                return -50;
            }

            // Get current slider values for component forces
            const sumForceVal = parseFloat(d3.select("#sum-force").property("value")) / 100;
            const productForceVal = parseFloat(d3.select("#product-force").property("value")) / 100;
            const linkStrengthVal = parseFloat(d3.select("#link-strength").property("value"));
            const chargeStrengthVal = parseFloat(d3.select("#charge-strength").property("value"));

            simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links)
                    .id(d => d.id)
                    .distance(linkDistance)
                    .strength(d => linkStrengthVal / 100))
                .force("charge", d3.forceManyBody()
                    .strength(chargeStrengthVal))
                .force("center", d3.forceCenter(width / 2, height / 2).strength(0.05))
                .force("collision", d3.forceCollide().radius(12))
                .force("radial", d3.forceRadial(d => {
                    // Keep non-hub nodes at reasonable distance from center
                    if (d.isHub) return 0;
                    return 150;
                }, width / 2, height / 2).strength(d => d.isHub ? 0 : 0.02))
                .force("sumComponent", forceComponentGroup(nodes, "sum_component", sumForceVal))
                .force("productComponent", forceComponentGroup(nodes, "product_component", productForceVal))
                .alpha(0.5)
                .alphaDecay(0.02);

            // Draw links
            const link = linkGroup.selectAll("line")
                .data(links)
                .join("line")
                .attr("class", "link");

            // Draw nodes
            const node = nodeGroup.selectAll("circle")
                .data(nodes)
                .join("circle")
                .attr("class", "node")
                .attr("r", 8)
                .attr("fill", "#000000")
                .call(drag(simulation));

            // Draw labels
            const label = labelGroup.selectAll("text")
                .data(nodes)
                .join("text")
                .attr("class", "node-label")
                .attr("text-anchor", "middle")
                .attr("dy", ".35em")
                .text(d => showLabels ? d.id : "")
                .style("pointer-events", "none");

            // Update positions on tick
            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);

                label
                    .attr("x", d => d.x)
                    .attr("y", d => d.y);
            });

            updateInfoPanel(graph);
        }

        function drag(simulation) {
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                if (!physicsEnabled) {
                    d.fx = event.x;
                    d.fy = event.y;
                } else {
                    d.fx = null;
                    d.fy = null;
                }
            }

            return d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended);
        }

        function togglePhysics() {
            physicsEnabled = !physicsEnabled;
            const btn = document.getElementById("physics-toggle");

            if (physicsEnabled) {
                btn.textContent = "Freeze Physics";
                if (simulation) {
                    simulation.alpha(0.3).restart();
                    // Unfix all nodes
                    simulation.nodes().forEach(d => {
                        d.fx = null;
                        d.fy = null;
                    });
                }
            } else {
                btn.textContent = "Unfreeze Physics";
                if (simulation) {
                    simulation.stop();
                }
            }
        }

        function toggleLabels() {
            showLabels = !showLabels;
            labelGroup.selectAll("text")
                .text(d => showLabels ? d.id : "");
        }

        function resetPositions() {
            if (currentGraph) {
                loadGraph(currentGraph);
            }
        }

        function updateLinkStrength() {
            const val = parseFloat(d3.select("#link-strength").property("value"));
            d3.select("#link-strength-val").text(val);

            if (simulation) {
                simulation.force("link").strength(val / 100);
                simulation.alpha(0.3).restart();
            }
        }

        function updateChargeStrength() {
            const val = parseFloat(d3.select("#charge-strength").property("value"));
            d3.select("#charge-strength-val").text(val);

            if (simulation) {
                simulation.force("charge").strength(val);
                simulation.alpha(0.3).restart();
            }
        }

        function updateSumForce() {
            const val = parseFloat(d3.select("#sum-force").property("value"));
            d3.select("#sum-force-val").text(val);

            if (simulation && simulation.force("sumComponent")) {
                simulation.force("sumComponent").strength(val / 100);
                simulation.alpha(0.3).restart();
            }
        }

        function updateProductForce() {
            const val = parseFloat(d3.select("#product-force").property("value"));
            d3.select("#product-force-val").text(val);

            if (simulation && simulation.force("productComponent")) {
                simulation.force("productComponent").strength(val / 100);
                simulation.alpha(0.3).restart();
            }
        }

        // Custom force for component-based attraction/repulsion
        function forceComponentGroup(nodes, componentKey, strength) {
            let strengthVal = strength;

            function force(alpha) {
                if (Math.abs(strengthVal) < 0.001) return;

                // Group nodes by their component
                const groups = new Map();
                nodes.forEach(n => {
                    const comp = n[componentKey];
                    if (comp !== undefined && comp !== null) {
                        if (!groups.has(comp)) groups.set(comp, []);
                        groups.get(comp).push(n);
                    }
                });

                // Apply forces within each group
                groups.forEach(groupNodes => {
                    if (groupNodes.length < 2) return;

                    // Calculate group center
                    let cx = 0, cy = 0;
                    groupNodes.forEach(n => { cx += n.x; cy += n.y; });
                    cx /= groupNodes.length;
                    cy /= groupNodes.length;

                    // Apply force toward/away from center
                    groupNodes.forEach(n => {
                        const dx = cx - n.x;
                        const dy = cy - n.y;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 1;

                        // Positive strength = attract, negative = repel
                        const factor = strengthVal * alpha * 0.5;
                        n.vx += (dx / dist) * factor;
                        n.vy += (dy / dist) * factor;
                    });
                });
            }

            force.strength = function(s) {
                if (arguments.length) { strengthVal = s; return force; }
                return strengthVal;
            };

            return force;
        }

        function updateInfoPanel(graph) {
            const content = d3.select("#info-content");
            content.html("");

            // Basic info
            const basicInfo = content.append("div").attr("class", "info-section");
            basicInfo.append("h3").text("Properties");

            [
                ["K_{s,t}", `K_{${graph.s},${graph.t}}`],
                ["Vertices", graph.n],
                ["Edges", graph.edges_count],
                ["Cotree Depth", graph.depth !== undefined ? graph.depth : "N/A"],
                ["Last Operation", graph.last_op || "N/A"],
                ["Component Sizes", graph.component_sizes && graph.component_sizes.length > 0 ? `[${graph.component_sizes.join(', ')}]` : "N/A"],
                ["Structure #", `${graph.struct_index + 1} / ${graph.total_structures}`],
                ["Exceptional", graph.is_exceptional ? "YES" : "No"]
            ].forEach(([label, value]) => {
                const row = basicInfo.append("div").attr("class", "info-row");
                row.append("span").attr("class", "info-label").text(label);
                row.append("span").attr("class", "info-value").text(value);
            });

            // Structure string
            const structInfo = content.append("div").attr("class", "info-section");
            structInfo.append("h3").text("Cotree Structure");
            structInfo.append("pre").text(graph.structure);

            // Node info
            const nodeInfo = content.append("div").attr("class", "info-section");
            nodeInfo.append("h3").text("Node Details");

            const maxDepth = d3.max(graph.nodes, d => d.depth);
            nodeInfo.append("div").attr("class", "info-row")
                .html(`<span class="info-label">Max Depth</span><span class="info-value">${maxDepth}</span>`);

            const depthCounts = d3.rollup(graph.nodes, v => v.length, d => d.depth);
            const depthInfo = nodeInfo.append("pre");
            depthInfo.text("Nodes per depth:\n" +
                Array.from(depthCounts).sort((a, b) => a[0] - b[0])
                    .map(([depth, count]) => `  Depth ${depth}: ${count} nodes`)
                    .join("\n"));
        }
    </script>
</body>
</html>
