<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extremal Cograph Viewer - D3.js</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: #f8f9fa;
            overflow: hidden;
        }

        #app {
            display: grid;
            grid-template-columns: 280px 1fr 320px;
            grid-template-rows: 60px 1fr;
            height: 100vh;
            gap: 0;
        }

        #header {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 25px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        #header h1 {
            font-size: 24px;
            font-weight: 600;
        }

        #header .stats {
            font-size: 14px;
            opacity: 0.9;
        }

        #header .folder-selector {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #header .folder-selector select {
            padding: 6px 12px;
            border-radius: 5px;
            border: none;
            font-size: 13px;
            background: rgba(255,255,255,0.9);
            cursor: pointer;
            min-width: 180px;
        }

        #header .folder-selector select:disabled {
            opacity: 0.7;
            cursor: wait;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-overlay.hidden {
            display: none;
        }

        .loading-box {
            background: white;
            padding: 30px 50px;
            border-radius: 10px;
            text-align: center;
        }

        .loading-box .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #e9ecef;
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .no-folder-message {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #6c757d;
            text-align: center;
            padding: 40px;
        }

        .no-folder-message h3 {
            font-size: 20px;
            margin-bottom: 10px;
            color: #495057;
        }

        .no-folder-message p {
            font-size: 14px;
            max-width: 300px;
        }

        #sidebar {
            background: white;
            border-right: 1px solid #dee2e6;
            overflow-y: auto;
            padding: 20px;
        }

        #main {
            background: white;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .split-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .split-pane {
            position: relative;
            overflow: hidden;
            min-height: 50px;
        }

        .split-pane.hidden {
            display: none;
        }

        #graph-pane {
            flex: 1;
            min-height: 100px;
        }

        .split-divider {
            height: 8px;
            background: #dee2e6;
            cursor: ns-resize;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .split-divider:hover {
            background: #667eea;
        }

        .split-divider::after {
            content: '';
            width: 40px;
            height: 4px;
            background: #adb5bd;
            border-radius: 2px;
        }

        .split-divider:hover::after {
            background: white;
        }

        .split-divider.hidden {
            display: none;
        }

        #cotree-pane {
            flex: 1;
            background: #fafafa;
            min-height: 100px;
        }

        .pane-label {
            position: absolute;
            top: 5px;
            left: 10px;
            font-size: 11px;
            color: #999;
            z-index: 5;
        }

        .cotree-node-label {
            font-size: 14px;
            font-weight: bold;
            fill: white;
            pointer-events: none;
            user-select: none;
            text-anchor: middle;
            dominant-baseline: central;
        }

        #info-panel {
            background: white;
            border-left: 1px solid #dee2e6;
            overflow-y: auto;
            padding: 20px;
        }

        h2 {
            font-size: 16px;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }

        .filter-group {
            margin-bottom: 20px;
        }

        .filter-group label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            color: #555;
            margin-bottom: 6px;
        }

        .filter-group select,
        .filter-group input {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            font-size: 13px;
            background: white;
        }

        .filter-group input[type="checkbox"] {
            width: auto;
            margin-right: 8px;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: 8px 0;
        }

        .button-group {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        button {
            padding: 8px 14px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: background 0.2s;
        }

        button:hover {
            background: #5568d3;
        }

        button.secondary {
            background: #6c757d;
        }

        button.secondary:hover {
            background: #5a6268;
        }

        #graph-list {
            margin-top: 15px;
        }

        .graph-item {
            padding: 12px;
            margin-bottom: 8px;
            background: #f8f9fa;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .graph-item:hover {
            background: #e9ecef;
            transform: translateX(2px);
        }

        .graph-item.active {
            background: #e7f1ff;
            border-color: #667eea;
        }

        .graph-label {
            font-weight: 600;
            color: #495057;
            font-size: 13px;
            margin-bottom: 4px;
        }

        .graph-meta {
            font-size: 11px;
            color: #6c757d;
        }


        svg {
            width: 100%;
            height: 100%;
        }

        .node {
            stroke: #fff;
            stroke-width: 2px;
            cursor: move;
        }

        .node:hover {
            stroke: #ffc107;
            stroke-width: 3px;
        }

        .link {
            stroke: #999;
            stroke-opacity: 0.3;
            stroke-width: 1.5px;
        }

        .link:hover {
            stroke-opacity: 0.7;
        }

        .node-label {
            font-size: 10px;
            font-weight: 600;
            fill: #333;
            pointer-events: none;
            user-select: none;
        }

        .slider-group {
            margin: 15px 0;
        }

        .slider-group label {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #555;
            margin-bottom: 5px;
        }

        input[type="range"] {
            width: 100%;
        }

        .info-section {
            margin-bottom: 20px;
        }

        .info-section h3 {
            font-size: 14px;
            color: #667eea;
            margin-bottom: 8px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid #e9ecef;
            font-size: 13px;
        }

        .info-label {
            font-weight: 500;
            color: #6c757d;
        }

        .info-value {
            font-weight: 600;
            color: #333;
        }

        pre {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 5px;
            font-size: 11px;
            overflow-x: auto;
            border: 1px solid #dee2e6;
            max-height: 200px;
        }

        .controls-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 10;
        }

        .control-item {
            margin-bottom: 10px;
        }

        .control-item:last-child {
            margin-bottom: 0;
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="header">
            <h1>Extremal Cograph Viewer</h1>
            <div class="folder-selector">
                <label style="font-size: 13px;">Exports folder:</label>
                <select id="folder-select">
                    <option value="">-- Select folder --</option>
                </select>
                <label style="font-size: 12px; display: flex; align-items: center; gap: 5px; cursor: pointer;">
                    <input type="checkbox" id="force-recalculate" style="cursor: pointer;">
                    Recalculate
                </label>
            </div>
            <div class="stats">
                <span id="total-graphs">0</span> graphs loaded
                | <span id="current-graph-label">Select a graph</span>
            </div>
        </div>

        <div id="loading-overlay" class="loading-overlay hidden">
            <div class="loading-box">
                <div class="spinner"></div>
                <div>Loading graphs...</div>
            </div>
        </div>

        <div id="sidebar">
            <h2>Filters</h2>

            <div class="filter-group">
                <label for="filter-st">Filter by K_{s,t}:</label>
                <select id="filter-st">
                    <option value="">All</option>
                </select>
            </div>

            <div class="filter-group">
                <label for="filter-n">Filter by n:</label>
                <select id="filter-n">
                    <option value="">All</option>
                </select>
            </div>

            <div class="button-group">
                <button onclick="resetFilters()">Reset Filters</button>
            </div>

            <h2 style="margin-top: 20px;">Graphs</h2>
            <div id="graph-list"></div>
        </div>

        <div id="main">
            <div class="controls-panel">
                <!-- View mode toggle -->
                <div class="control-item" style="margin-bottom: 12px; padding-bottom: 10px; border-bottom: 1px solid #dee2e6;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 13px; font-weight: 600;">
                        <input type="checkbox" id="split-view-mode" checked style="width: 18px; height: 18px; cursor: pointer;"> Split View
                    </label>
                </div>

                <!-- Split view controls (Graph/Cotree checkboxes) -->
                <div id="split-view-controls" class="control-item" style="margin-bottom: 15px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 14px; margin-bottom: 10px;">
                        <input type="checkbox" id="show-graph" checked style="width: 18px; height: 18px; cursor: pointer;"> Graph
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 14px;">
                        <input type="checkbox" id="show-cotree" checked style="width: 18px; height: 18px; cursor: pointer;"> Cotree
                    </label>
                </div>

                <div class="control-item">
                    <button onclick="togglePhysics()" id="physics-toggle">Freeze Physics</button>
                </div>
                <div class="control-item">
                    <button onclick="toggleLabels()" class="secondary">Toggle Labels</button>
                </div>
                <div class="control-item">
                    <button onclick="resetPositions()" class="secondary">Reset Layout</button>
                </div>

                <!-- Graph sliders -->
                <div id="graph-sliders">
                    <div style="font-size: 11px; color: #667eea; font-weight: 600; margin: 10px 0 5px; border-top: 1px solid #dee2e6; padding-top: 10px;">Graph</div>
                    <div class="slider-group">
                        <label>
                            <span>Link Strength</span>
                            <span id="graph-link-strength-val">30</span>
                        </label>
                        <input type="range" id="graph-link-strength" min="-100" max="100" step="1" value="30">
                    </div>
                    <div class="slider-group">
                        <label>
                            <span>Charge Force</span>
                            <span id="graph-charge-strength-val">-30</span>
                        </label>
                        <input type="range" id="graph-charge-strength" min="-100" max="100" step="1" value="-30">
                    </div>
                    <div class="slider-group">
                        <label>
                            <span>Sum Force</span>
                            <span id="graph-sum-force-val">0</span>
                        </label>
                        <input type="range" id="graph-sum-force" min="-100" max="100" step="1" value="0">
                    </div>
                    <div class="slider-group">
                        <label>
                            <span>Product Force</span>
                            <span id="graph-product-force-val">0</span>
                        </label>
                        <input type="range" id="graph-product-force" min="-100" max="100" step="1" value="0">
                    </div>
                </div>

                <!-- Cotree sliders -->
                <div id="cotree-sliders">
                    <div style="font-size: 11px; color: #667eea; font-weight: 600; margin: 10px 0 5px; border-top: 1px solid #dee2e6; padding-top: 10px;">Cotree</div>
                    <div class="slider-group">
                        <label>
                            <span>Link Strength</span>
                            <span id="cotree-link-strength-val">30</span>
                        </label>
                        <input type="range" id="cotree-link-strength" min="-100" max="100" step="1" value="30">
                    </div>
                    <div class="slider-group">
                        <label>
                            <span>Charge Force</span>
                            <span id="cotree-charge-strength-val">-30</span>
                        </label>
                        <input type="range" id="cotree-charge-strength" min="-100" max="100" step="1" value="-30">
                    </div>
                </div>
            </div>
            <div class="split-container">
                <div id="graph-pane" class="split-pane">
                    <div class="pane-label">Graph</div>
                    <svg id="graph-svg"></svg>
                </div>
                <div id="split-divider" class="split-divider"></div>
                <div id="cotree-pane" class="split-pane">
                    <div class="pane-label">Cotree</div>
                    <svg id="cotree-svg"></svg>
                </div>
            </div>
        </div>

        <div id="info-panel">
            <h2>Graph Information</h2>
            <div id="info-content">
                <p style="color: #6c757d; font-size: 13px;">Select a graph from the list to view details</p>
            </div>
        </div>
    </div>

    <script>
        let allGraphs = [];
        let filteredGraphs = [];
        let currentGraph = null;
        let simulation = null;
        let cotreeSimulation = null;
        let physicsEnabled = true;
        let showLabels = false;
        let currentFolder = null;
        let splitViewMode = true;

        // Graph SVG setup
        const svg = d3.select("#graph-svg");
        const graphPane = document.getElementById("graph-pane");
        let width = graphPane.clientWidth || 800;
        let height = graphPane.clientHeight || 400;

        svg.attr("viewBox", [0, 0, width, height]);

        const g = svg.append("g");
        const linkGroup = g.append("g").attr("class", "links");
        const nodeGroup = g.append("g").attr("class", "nodes");
        const labelGroup = g.append("g").attr("class", "labels");

        // Graph zoom
        const zoom = d3.zoom()
            .scaleExtent([0.1, 10])
            .on("zoom", (event) => {
                g.attr("transform", event.transform);
            });
        svg.call(zoom);

        // Cotree SVG setup
        const cotreeSvg = d3.select("#cotree-svg");
        const cotreePane = document.getElementById("cotree-pane");
        let cotreeWidth = cotreePane.clientWidth || 800;
        let cotreeHeight = cotreePane.clientHeight || 400;

        cotreeSvg.attr("viewBox", [0, 0, cotreeWidth, cotreeHeight]);

        const cotreeG = cotreeSvg.append("g");
        const cotreeLinkGroup = cotreeG.append("g").attr("class", "cotree-links");
        const cotreeNodeGroup = cotreeG.append("g").attr("class", "cotree-nodes");
        const cotreeLabelGroup = cotreeG.append("g").attr("class", "cotree-labels");

        // Cotree zoom
        const cotreeZoom = d3.zoom()
            .scaleExtent([0.1, 10])
            .on("zoom", (event) => {
                cotreeG.attr("transform", event.transform);
            });
        cotreeSvg.call(cotreeZoom);

        // Toggle between single view and split view modes
        function toggleViewMode() {
            splitViewMode = document.getElementById("split-view-mode").checked;
            updatePaneVisibility();

            // Reload current graph to apply changes
            if (currentGraph) {
                loadGraph(currentGraph);
            }
        }

        // Pane visibility toggles
        function updatePaneVisibility() {
            const showGraph = document.getElementById("show-graph").checked;
            const showCotree = document.getElementById("show-cotree").checked;

            if (splitViewMode) {
                // Split view mode: show controls and both panes as configured
                document.getElementById("split-view-controls").style.display = "block";
                document.getElementById("graph-pane").classList.toggle("hidden", !showGraph);
                document.getElementById("cotree-pane").classList.toggle("hidden", !showCotree);
                document.getElementById("split-divider").classList.toggle("hidden", !showGraph || !showCotree);

                // Show/hide slider groups based on pane visibility
                document.getElementById("graph-sliders").style.display = showGraph ? "block" : "none";
                document.getElementById("cotree-sliders").style.display = showCotree ? "block" : "none";
            } else {
                // Single view mode: hide split controls, show only graph pane full size
                document.getElementById("split-view-controls").style.display = "none";
                document.getElementById("graph-pane").classList.remove("hidden");
                document.getElementById("graph-pane").style.flex = "1";
                document.getElementById("cotree-pane").classList.add("hidden");
                document.getElementById("split-divider").classList.add("hidden");

                // Show only graph sliders in single view
                document.getElementById("graph-sliders").style.display = "block";
                document.getElementById("cotree-sliders").style.display = "none";
            }

            // Update viewboxes after visibility change
            setTimeout(updateDimensions, 50);
        }

        function updateDimensions() {
            width = graphPane.clientWidth || 800;
            height = graphPane.clientHeight || 400;
            svg.attr("viewBox", [0, 0, width, height]);

            cotreeWidth = cotreePane.clientWidth || 800;
            cotreeHeight = cotreePane.clientHeight || 400;
            cotreeSvg.attr("viewBox", [0, 0, cotreeWidth, cotreeHeight]);
        }

        // Resizable split divider
        (function() {
            const divider = document.getElementById("split-divider");
            const container = document.querySelector(".split-container");
            let isDragging = false;

            divider.addEventListener("mousedown", (e) => {
                isDragging = true;
                document.body.style.cursor = "ns-resize";
                document.body.style.userSelect = "none";
                e.preventDefault();
            });

            document.addEventListener("mousemove", (e) => {
                if (!isDragging) return;

                const containerRect = container.getBoundingClientRect();
                const offsetY = e.clientY - containerRect.top;
                const totalHeight = containerRect.height;

                // Calculate percentage (leave room for divider)
                const dividerHeight = 8;
                const minHeight = 100;
                const availableHeight = totalHeight - dividerHeight;

                let graphHeight = offsetY - dividerHeight / 2;
                graphHeight = Math.max(minHeight, Math.min(availableHeight - minHeight, graphHeight));

                const graphPercent = (graphHeight / availableHeight) * 100;
                const cotreePercent = 100 - graphPercent;

                graphPane.style.flex = `0 0 ${graphPercent}%`;
                cotreePane.style.flex = `0 0 ${cotreePercent}%`;

                updateDimensions();
            });

            document.addEventListener("mouseup", () => {
                if (isDragging) {
                    isDragging = false;
                    document.body.style.cursor = "";
                    document.body.style.userSelect = "";
                }
            });
        })();

        // Parse cotree structure string into nodes and links
        function parseCotreeStructure(structStr) {
            const nodes = [];
            const links = [];
            let nodeId = 0;

            function parse(str, parentId = null) {
                str = str.trim();

                // Check if it's a leaf (just "1")
                if (str === "1") {
                    const id = nodeId++;
                    nodes.push({ id, type: "leaf", label: "" });
                    if (parentId !== null) {
                        links.push({ source: parentId, target: id });
                    }
                    return id;
                }

                // Check for S(...) or P(...)
                let op = null;
                let innerStart = 0;
                if (str.startsWith("S(")) {
                    op = "sum";
                    innerStart = 2;
                } else if (str.startsWith("P(")) {
                    op = "product";
                    innerStart = 2;
                }

                if (op) {
                    const id = nodeId++;
                    nodes.push({ id, type: op, label: op === "sum" ? "+" : "×" });
                    if (parentId !== null) {
                        links.push({ source: parentId, target: id });
                    }

                    // Parse children - need to handle nested parentheses
                    const inner = str.slice(innerStart, -1); // Remove S( and )
                    const children = splitTopLevel(inner);

                    for (const child of children) {
                        parse(child, id);
                    }

                    return id;
                }

                return null;
            }

            // Split by comma at top level (not inside parentheses)
            function splitTopLevel(str) {
                const parts = [];
                let depth = 0;
                let current = "";

                for (const char of str) {
                    if (char === "(") depth++;
                    else if (char === ")") depth--;
                    else if (char === "," && depth === 0) {
                        parts.push(current.trim());
                        current = "";
                        continue;
                    }
                    current += char;
                }
                if (current.trim()) parts.push(current.trim());
                return parts;
            }

            parse(structStr);
            return { nodes, links };
        }

        // Render cotree visualization using hierarchical tree layout
        function renderCotree(graph) {
            if (!graph || !graph.structure) return;

            // Update dimensions
            cotreeWidth = cotreePane.clientWidth || 800;
            cotreeHeight = cotreePane.clientHeight || 400;
            cotreeSvg.attr("viewBox", [0, 0, cotreeWidth, cotreeHeight]);

            // Parse into hierarchical structure for d3.tree
            const hierarchyData = parseCotreeHierarchy(graph.structure);
            if (!hierarchyData) return;

            // Clear existing
            cotreeLinkGroup.selectAll("*").remove();
            cotreeNodeGroup.selectAll("*").remove();
            cotreeLabelGroup.selectAll("*").remove();

            // Stop existing simulation
            if (cotreeSimulation) {
                cotreeSimulation.stop();
            }

            // Create hierarchy and use radial layout for initial positions
            const root = d3.hierarchy(hierarchyData);

            // Flatten to nodes and links for D3
            const descendants = root.descendants();
            const nodes = descendants.map((d, i) => {
                // Place nodes in a radial pattern based on depth
                const depth = d.depth;
                const siblings = d.parent ? d.parent.children : [d];
                const siblingIndex = siblings.indexOf(d);
                const siblingCount = siblings.length;

                // Radial positioning: root at center, children spread in circles
                const baseAngle = d.parent ?
                    (2 * Math.PI * siblingIndex / siblingCount) + (Math.random() - 0.5) * 0.3 : 0;
                const radius = depth * 60 + (Math.random() - 0.5) * 20;

                return {
                    id: i,
                    x: cotreeWidth / 2 + Math.cos(baseAngle) * radius,
                    y: cotreeHeight / 2 + Math.sin(baseAngle) * radius,
                    type: d.data.type,
                    label: d.data.label,
                    depth: depth
                };
            });

            const links = root.links().map(d => ({
                source: nodes[descendants.indexOf(d.source)],
                target: nodes[descendants.indexOf(d.target)]
            }));

            // Get current slider values for cotree
            const linkStrengthVal = parseFloat(d3.select("#cotree-link-strength").property("value"));
            const chargeStrengthVal = parseFloat(d3.select("#cotree-charge-strength").property("value"));

            // Scale forces based on tree size
            const scaleFactor = Math.max(1, Math.sqrt(nodes.length / 20));
            const linkDist = 50 / scaleFactor;

            // Create force simulation - nodes can move freely in all directions
            cotreeSimulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links)
                    .id(d => d.id)
                    .distance(linkDist)
                    .strength(Math.abs(linkStrengthVal) / 100))
                .force("charge", d3.forceManyBody()
                    .strength(chargeStrengthVal / scaleFactor))
                .force("center", d3.forceCenter(cotreeWidth / 2, cotreeHeight / 2).strength(0.05))
                .force("collision", d3.forceCollide().radius(d => d.type === "leaf" ? 10 : 16))
                .alpha(0.5)
                .alphaDecay(0.02);

            // Draw links
            const link = cotreeLinkGroup.selectAll("line")
                .data(links)
                .join("line")
                .attr("stroke", "#999")
                .attr("stroke-opacity", 0.6)
                .attr("stroke-width", 1.5);

            // Draw nodes
            const node = cotreeNodeGroup.selectAll("circle")
                .data(nodes)
                .join("circle")
                .attr("r", d => d.type === "leaf" ? 8 : 14)
                .attr("fill", "#000")
                .attr("stroke", "#fff")
                .attr("stroke-width", 2)
                .call(cotreeDrag(cotreeSimulation));

            // Draw labels (+ or ×)
            const label = cotreeLabelGroup.selectAll("text")
                .data(nodes.filter(n => n.type !== "leaf"))
                .join("text")
                .attr("class", "cotree-node-label")
                .text(d => d.label);

            // Update positions on tick with boundary constraints
            const padding = 20;
            cotreeSimulation.on("tick", () => {
                // Clamp nodes within boundaries
                nodes.forEach(d => {
                    d.x = Math.max(padding, Math.min(cotreeWidth - padding, d.x));
                    d.y = Math.max(padding, Math.min(cotreeHeight - padding, d.y));
                });

                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);

                label
                    .attr("x", d => d.x)
                    .attr("y", d => d.y);
            });
        }

        // Parse cotree into hierarchical format for d3.hierarchy
        function parseCotreeHierarchy(structStr) {
            function parse(str) {
                str = str.trim();

                if (str === "1") {
                    return { type: "leaf", label: "", children: [] };
                }

                let op = null;
                let innerStart = 0;
                if (str.startsWith("S(")) {
                    op = "sum";
                    innerStart = 2;
                } else if (str.startsWith("P(")) {
                    op = "product";
                    innerStart = 2;
                }

                if (op) {
                    const inner = str.slice(innerStart, -1);
                    const childStrs = splitTopLevel(inner);
                    const children = childStrs.map(c => parse(c)).filter(c => c !== null);

                    return {
                        type: op,
                        label: op === "sum" ? "+" : "×",
                        children: children
                    };
                }

                return null;
            }

            function splitTopLevel(str) {
                const parts = [];
                let depth = 0;
                let current = "";

                for (const char of str) {
                    if (char === "(") depth++;
                    else if (char === ")") depth--;
                    else if (char === "," && depth === 0) {
                        parts.push(current.trim());
                        current = "";
                        continue;
                    }
                    current += char;
                }
                if (current.trim()) parts.push(current.trim());
                return parts;
            }

            return parse(structStr);
        }

        // Cotree drag handler
        function cotreeDrag(simulation) {
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                if (physicsEnabled) {
                    d.fx = null;
                    d.fy = null;
                }
            }

            return d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended);
        }

        // Show/hide loading overlay
        function showLoading(show) {
            document.getElementById("loading-overlay").classList.toggle("hidden", !show);
            document.getElementById("folder-select").disabled = show;
        }

        // Show "no folder selected" message
        function showNoFolderMessage() {
            const list = d3.select("#graph-list");
            list.html(`
                <div class="no-folder-message">
                    <h3>No folder selected</h3>
                    <p>Select an exports folder from the dropdown above to view graphs</p>
                </div>
            `);
            d3.select("#total-graphs").text("0");
            d3.select("#current-graph-label").text("Select a folder first");

            // Clear the graph display
            linkGroup.selectAll("*").remove();
            nodeGroup.selectAll("*").remove();
            labelGroup.selectAll("*").remove();

            // Clear the cotree display
            cotreeLinkGroup.selectAll("*").remove();
            cotreeNodeGroup.selectAll("*").remove();
            cotreeLabelGroup.selectAll("*").remove();

            // Clear info panel
            d3.select("#info-content").html(`
                <p style="color: #6c757d; font-size: 13px;">Select a folder and graph to view details</p>
            `);
        }

        // Load available folders
        async function loadFolders() {
            try {
                const response = await fetch("/api/folders");
                const folders = await response.json();

                const select = document.getElementById("folder-select");
                // Clear existing options except the first
                while (select.options.length > 1) {
                    select.remove(1);
                }

                folders.forEach(folder => {
                    const option = document.createElement("option");
                    option.value = folder.path;
                    const cacheIndicator = folder.has_cache ? " [cached]" : "";
                    option.textContent = `${folder.name} (${folder.file_count} files)${cacheIndicator}`;
                    select.appendChild(option);
                });
            } catch (error) {
                console.error("Failed to load folders:", error);
            }
        }

        // Handle folder selection
        async function selectFolder(folderPath, force = false) {
            if (!folderPath) {
                showNoFolderMessage();
                return;
            }

            showLoading(true);
            currentFolder = folderPath;

            try {
                const response = await fetch("/api/select-folder", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ folder: folderPath, force: force })
                });

                const result = await response.json();
                if (!response.ok) {
                    alert("Error: " + (result.error || "Failed to load folder"));
                    showLoading(false);
                    return;
                }

                // Load data directly from response
                allGraphs = result.data || [];
                currentGraph = null;

                if (allGraphs.length === 0) {
                    showNoFolderMessage();
                    return;
                }

                // Update status to show if cache was used
                const statusText = result.used_cache ? "(cached)" : "(generated)";
                console.log(`Loaded ${allGraphs.length} graphs ${statusText}`);

                // Refresh folder list to update cache indicators
                const currentValue = document.getElementById("folder-select").value;
                await loadFolders();
                document.getElementById("folder-select").value = currentValue;

                initializeFilters();
                applyFilters();

            } catch (error) {
                console.error("Failed to select folder:", error);
                alert("Failed to load folder: " + error.message);
            } finally {
                showLoading(false);
            }
        }

        // Initialize on page load
        document.addEventListener("DOMContentLoaded", async () => {
            await loadFolders();

            // Set up folder selector
            document.getElementById("folder-select").addEventListener("change", (e) => {
                const forceRecalc = document.getElementById("force-recalculate").checked;
                selectFolder(e.target.value, forceRecalc);
            });

            // Set up view mode toggle
            document.getElementById("split-view-mode").addEventListener("change", toggleViewMode);

            // Set up pane visibility toggles
            document.getElementById("show-graph").addEventListener("change", updatePaneVisibility);
            document.getElementById("show-cotree").addEventListener("change", updatePaneVisibility);

            // Initialize slider visibility
            updatePaneVisibility();

            // Show no folder message initially
            showNoFolderMessage();
        });

        function initializeFilters() {
            // Clear existing options first
            const stSelect = d3.select("#filter-st");
            stSelect.selectAll("option").remove();
            stSelect.append("option").attr("value", "").text("All");

            const nSelect = d3.select("#filter-n");
            nSelect.selectAll("option").remove();
            nSelect.append("option").attr("value", "").text("All");

            // Populate s,t filter
            const stSet = new Set(allGraphs.map(g => `${g.s},${g.t}`));
            Array.from(stSet).sort((a, b) => {
                const [s1, t1] = a.split(',').map(Number);
                const [s2, t2] = b.split(',').map(Number);
                return s1 !== s2 ? s1 - s2 : t1 - t2;
            }).forEach(st => {
                const [s, t] = st.split(',');
                stSelect.append("option")
                    .attr("value", st)
                    .text(`K_{${s},${t}}`);
            });

            // Populate n filter
            const nSet = new Set(allGraphs.map(g => g.n));
            Array.from(nSet).sort((a, b) => a - b).forEach(n => {
                nSelect.append("option")
                    .attr("value", n)
                    .text(`n = ${n}`);
            });

            // Event listeners
            d3.select("#filter-st").on("change", applyFilters);
            d3.select("#filter-n").on("change", applyFilters);

            // Graph slider listeners
            d3.select("#graph-link-strength").on("input", updateGraphLinkStrength);
            d3.select("#graph-charge-strength").on("input", updateGraphChargeStrength);
            d3.select("#graph-sum-force").on("input", updateGraphSumForce);
            d3.select("#graph-product-force").on("input", updateGraphProductForce);

            // Cotree slider listeners
            d3.select("#cotree-link-strength").on("input", updateCotreeLinkStrength);
            d3.select("#cotree-charge-strength").on("input", updateCotreeChargeStrength);

            d3.select("#total-graphs").text(allGraphs.length);
        }

        function applyFilters() {
            const stFilter = d3.select("#filter-st").property("value");
            const nFilter = d3.select("#filter-n").property("value");

            filteredGraphs = allGraphs.filter(g => {
                if (stFilter && `${g.s},${g.t}` !== stFilter) return false;
                if (nFilter && g.n !== parseInt(nFilter)) return false;
                return true;
            });

            // Sort numerically by s, t, n, then struct_index
            filteredGraphs.sort((a, b) => {
                if (a.s !== b.s) return a.s - b.s;
                if (a.t !== b.t) return a.t - b.t;
                if (a.n !== b.n) return a.n - b.n;
                return a.struct_index - b.struct_index;
            });

            renderGraphList();
        }

        function resetFilters() {
            d3.select("#filter-st").property("value", "");
            d3.select("#filter-n").property("value", "");
            applyFilters();
        }

        function renderGraphList() {
            const list = d3.select("#graph-list");
            list.selectAll("*").remove();

            filteredGraphs.forEach((graph, i) => {
                const item = list.append("div")
                    .attr("class", "graph-item")
                    .on("click", () => loadGraph(graph));

                item.append("div")
                    .attr("class", "graph-label")
                    .text(graph.label);

                const metaText = [
                    `V: ${graph.n}`,
                    `E: ${graph.edges_count}`,
                    `D: ${graph.depth}`,
                    graph.last_op ? `Op: ${graph.last_op}` : null,
                    graph.component_sizes && graph.component_sizes.length > 0 ? `Comp: [${graph.component_sizes.join(',')}]` : null,
                    `#${graph.struct_index + 1}/${graph.total_structures}`
                ].filter(x => x !== null).join(' | ');

                item.append("div")
                    .attr("class", "graph-meta")
                    .text(metaText);
            });

            // Auto-load first graph
            if (filteredGraphs.length > 0 && !currentGraph) {
                loadGraph(filteredGraphs[0]);
            }
        }

        function loadGraph(graph) {
            currentGraph = graph;

            // Update active state
            d3.selectAll(".graph-item").classed("active", false);
            d3.selectAll(".graph-item").filter(function() {
                return d3.select(this).text().includes(graph.label);
            }).classed("active", true);

            // Update header
            d3.select("#current-graph-label").text(graph.label);

            // Prepare data
            const nodes = graph.nodes.map(n => ({...n}));
            const links = graph.links.map(l => ({...l}));

            // Clear existing
            linkGroup.selectAll("*").remove();
            nodeGroup.selectAll("*").remove();
            labelGroup.selectAll("*").remove();

            // Create force simulation with structure-aware parameters
            if (simulation) {
                simulation.stop();
            }

            // Use pre-computed positions as initial positions
            nodes.forEach(n => {
                n.x = n.x || width / 2;
                n.y = n.y || height / 2;
            });

            // Build adjacency for structure detection
            const adjacency = new Map();
            nodes.forEach(n => adjacency.set(n.id, new Set()));
            links.forEach(l => {
                const src = typeof l.source === 'object' ? l.source.id : l.source;
                const tgt = typeof l.target === 'object' ? l.target.id : l.target;
                adjacency.get(src).add(tgt);
                adjacency.get(tgt).add(src);
            });

            // Detect hub nodes (high degree relative to graph size)
            const avgDegree = links.length * 2 / nodes.length;
            nodes.forEach(n => {
                const degree = adjacency.get(n.id).size;
                n.isHub = n.is_hub || degree > avgDegree * 1.5;
            });

            // Structure-aware link distance
            function linkDistance(link) {
                const src = link.source;
                const tgt = link.target;

                // If connecting to hub, use longer distance
                if (src.isHub || tgt.isHub) {
                    return 80;
                }

                // Same branch: tight clustering
                if (src.branch !== undefined && src.branch === tgt.branch) {
                    return 30;
                }

                // Same multipartite part: tight
                if (src.multipartite_part !== undefined && src.multipartite_part === tgt.multipartite_part) {
                    return 30;
                }

                // Different branches/parts: longer
                return 60;
            }

            // Structure-aware link strength
            function linkStrength(link) {
                const src = link.source;
                const tgt = link.target;

                // Hub connections: weaker to allow radial spread
                if (src.isHub || tgt.isHub) {
                    return 0.3;
                }

                // Same structural group: strong
                if (src.branch !== undefined && src.branch === tgt.branch) {
                    return 1.0;
                }

                // Cross-branch: weaker
                return 0.5;
            }

            // Structure-aware charge (repulsion)
            function chargeStrength(node) {
                // Hub nodes need more space
                if (node.isHub) {
                    return -150;
                }
                // Regular nodes
                return -50;
            }

            // Get current slider values for graph
            const linkStrengthVal = parseFloat(d3.select("#graph-link-strength").property("value"));
            const chargeStrengthVal = parseFloat(d3.select("#graph-charge-strength").property("value"));
            const sumForceVal = parseFloat(d3.select("#graph-sum-force").property("value")) / 100;
            const productForceVal = parseFloat(d3.select("#graph-product-force").property("value")) / 100;

            simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links)
                    .id(d => d.id)
                    .distance(linkDistance)
                    .strength(linkStrengthVal / 100))
                .force("charge", d3.forceManyBody()
                    .strength(chargeStrengthVal))
                .force("center", d3.forceCenter(width / 2, height / 2).strength(0.05))
                .force("collision", d3.forceCollide().radius(12))
                .force("radial", d3.forceRadial(d => {
                    // Keep non-hub nodes at reasonable distance from center
                    if (d.isHub) return 0;
                    return 150;
                }, width / 2, height / 2).strength(d => d.isHub ? 0 : 0.02))
                .force("sumComponent", forceComponentGroup(nodes, "sum_component", sumForceVal))
                .force("productComponent", forceComponentGroup(nodes, "product_component", productForceVal))
                .alpha(0.5)
                .alphaDecay(0.02);

            // Draw links
            const link = linkGroup.selectAll("line")
                .data(links)
                .join("line")
                .attr("class", "link");

            // Draw nodes
            const node = nodeGroup.selectAll("circle")
                .data(nodes)
                .join("circle")
                .attr("class", "node")
                .attr("r", 8)
                .attr("fill", "#000000")
                .call(drag(simulation));

            // Draw labels
            const label = labelGroup.selectAll("text")
                .data(nodes)
                .join("text")
                .attr("class", "node-label")
                .attr("text-anchor", "middle")
                .attr("dy", ".35em")
                .text(d => showLabels ? d.id : "")
                .style("pointer-events", "none");

            // Update positions on tick with boundary constraints
            const padding = 20;
            simulation.on("tick", () => {
                // Clamp nodes within boundaries
                nodes.forEach(d => {
                    d.x = Math.max(padding, Math.min(width - padding, d.x));
                    d.y = Math.max(padding, Math.min(height - padding, d.y));
                });

                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);

                label
                    .attr("x", d => d.x)
                    .attr("y", d => d.y);
            });

            updateInfoPanel(graph);

            // Render cotree in the second pane (only in split view mode)
            if (splitViewMode && document.getElementById("show-cotree").checked) {
                renderCotree(graph);
            }
        }

        function drag(simulation) {
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                if (!physicsEnabled) {
                    d.fx = event.x;
                    d.fy = event.y;
                } else {
                    d.fx = null;
                    d.fy = null;
                }
            }

            return d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended);
        }

        function togglePhysics() {
            physicsEnabled = !physicsEnabled;
            const btn = document.getElementById("physics-toggle");

            if (physicsEnabled) {
                btn.textContent = "Freeze Physics";
                if (simulation) {
                    simulation.alpha(0.3).restart();
                    // Unfix all nodes
                    simulation.nodes().forEach(d => {
                        d.fx = null;
                        d.fy = null;
                    });
                }
                if (cotreeSimulation) {
                    cotreeSimulation.alpha(0.3).restart();
                    cotreeSimulation.nodes().forEach(d => {
                        d.fx = null;
                        d.fy = null;
                    });
                }
            } else {
                btn.textContent = "Unfreeze Physics";
                if (simulation) {
                    simulation.stop();
                }
                if (cotreeSimulation) {
                    cotreeSimulation.stop();
                }
            }
        }

        function toggleLabels() {
            showLabels = !showLabels;
            labelGroup.selectAll("text")
                .text(d => showLabels ? d.id : "");
        }

        function resetPositions() {
            if (currentGraph) {
                loadGraph(currentGraph);
            }
        }

        function updateGraphLinkStrength() {
            const val = parseFloat(d3.select("#graph-link-strength").property("value"));
            d3.select("#graph-link-strength-val").text(val);

            if (simulation) {
                simulation.force("link").strength(val / 100);
                simulation.alpha(0.3).restart();
            }
        }

        function updateGraphChargeStrength() {
            const val = parseFloat(d3.select("#graph-charge-strength").property("value"));
            d3.select("#graph-charge-strength-val").text(val);

            if (simulation) {
                simulation.force("charge").strength(val);
                simulation.alpha(0.3).restart();
            }
        }

        function updateCotreeLinkStrength() {
            const val = parseFloat(d3.select("#cotree-link-strength").property("value"));
            d3.select("#cotree-link-strength-val").text(val);

            if (cotreeSimulation) {
                const scaleFactor = Math.max(1, Math.sqrt(cotreeSimulation.nodes().length / 20));
                cotreeSimulation.force("link").strength(Math.abs(val) / 100);
                cotreeSimulation.alpha(0.3).restart();
            }
        }

        function updateCotreeChargeStrength() {
            const val = parseFloat(d3.select("#cotree-charge-strength").property("value"));
            d3.select("#cotree-charge-strength-val").text(val);

            if (cotreeSimulation) {
                const scaleFactor = Math.max(1, Math.sqrt(cotreeSimulation.nodes().length / 20));
                cotreeSimulation.force("charge").strength(val / scaleFactor);
                cotreeSimulation.alpha(0.3).restart();
            }
        }

        function updateGraphSumForce() {
            const val = parseFloat(d3.select("#graph-sum-force").property("value"));
            d3.select("#graph-sum-force-val").text(val);

            if (simulation && simulation.force("sumComponent")) {
                simulation.force("sumComponent").strength(val / 100);
                simulation.alpha(0.3).restart();
            }
        }

        function updateGraphProductForce() {
            const val = parseFloat(d3.select("#graph-product-force").property("value"));
            d3.select("#graph-product-force-val").text(val);

            if (simulation && simulation.force("productComponent")) {
                simulation.force("productComponent").strength(val / 100);
                simulation.alpha(0.3).restart();
            }
        }

        // Custom force for component-based attraction/repulsion
        function forceComponentGroup(nodes, componentKey, strength) {
            let strengthVal = strength;

            function force(alpha) {
                if (Math.abs(strengthVal) < 0.001) return;

                // Group nodes by their component
                const groups = new Map();
                nodes.forEach(n => {
                    const comp = n[componentKey];
                    if (comp !== undefined && comp !== null) {
                        if (!groups.has(comp)) groups.set(comp, []);
                        groups.get(comp).push(n);
                    }
                });

                // Apply forces within each group
                groups.forEach(groupNodes => {
                    if (groupNodes.length < 2) return;

                    // Calculate group center
                    let cx = 0, cy = 0;
                    groupNodes.forEach(n => { cx += n.x; cy += n.y; });
                    cx /= groupNodes.length;
                    cy /= groupNodes.length;

                    // Apply force toward/away from center
                    groupNodes.forEach(n => {
                        const dx = cx - n.x;
                        const dy = cy - n.y;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 1;

                        // Positive strength = attract, negative = repel
                        const factor = strengthVal * alpha * 0.5;
                        n.vx += (dx / dist) * factor;
                        n.vy += (dy / dist) * factor;
                    });
                });
            }

            force.strength = function(s) {
                if (arguments.length) { strengthVal = s; return force; }
                return strengthVal;
            };

            return force;
        }

        function updateInfoPanel(graph) {
            const content = d3.select("#info-content");
            content.html("");

            // Basic info
            const basicInfo = content.append("div").attr("class", "info-section");
            basicInfo.append("h3").text("Properties");

            [
                ["K_{s,t}", `K_{${graph.s},${graph.t}}`],
                ["Vertices", graph.n],
                ["Edges", graph.edges_count],
                ["Cotree Depth", graph.depth !== undefined ? graph.depth : "N/A"],
                ["Last Operation", graph.last_op || "N/A"],
                ["Component Sizes", graph.component_sizes && graph.component_sizes.length > 0 ? `[${graph.component_sizes.join(', ')}]` : "N/A"],
                ["Structure #", `${graph.struct_index + 1} / ${graph.total_structures}`]
            ].forEach(([label, value]) => {
                const row = basicInfo.append("div").attr("class", "info-row");
                row.append("span").attr("class", "info-label").text(label);
                row.append("span").attr("class", "info-value").text(value);
            });

            // Structure string
            const structInfo = content.append("div").attr("class", "info-section");
            structInfo.append("h3").text("Cotree Structure");
            structInfo.append("pre").text(graph.structure);
        }
    </script>
</body>
</html>
